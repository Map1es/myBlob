---
title: 常见排序算法
date: 2020-08-03
categories:
  - 杂
tags:
  - 算法
---

## 前言

虽然在工作的时候常用 sort 进行排序，但是还是需要了解一下一些常见的排序方法以及实现思路

## 算法概述

1. 排序分类

- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。（冒泡、快排、插入、选择、希尔、堆排序、归并）

- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。（计数、桶排序、基数）

2. 算法复杂度

![算法复杂度](../images/200803/all.png)

3. 相关概念

- 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面。
- 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。

虽然上面列举了很多排序方法，但本篇文章只会详细解释比较简单的排序方法

## 1、冒泡排序

这是一个简单的排序方法。它需要重复走过需要排序的数列，两两比较，如果顺序错误则交换位置。直到所有数字不需交换为止。如下动图，就像数字冒泡一样

![冒泡排序](../images/200803/bubble.gif)

代码实现：

```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let flag = false;
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j + 1] < arr[j]) {
        flag = true; // 算法优化，如果该次排序没有交换，则说明已经排序结束，不需要继续下去
        let temp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = temp;
      }
    }
    if (!flag) {
      break;
    }
  }
  return arr;
}
```

## 2、选择排序

选择排序是比较直观的排序方法。每次只需要选取数列中最大（小）的数，放在数列前面，直到元素都排序完毕。

![选择排序](../images/200803/select.gif)

代码实现：

```javascript
function selectSort(arr) {
  let minIndex, temp;
  for (let i = 0; i < arr.length - 1; i++) {
    minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
  }
  return arr;
}
```

因为无论什么数据进去都是 O(n2)的时间复杂度, 所以使用该算法时，数据越少越好。

## 3、插入排序

插入排序也是一种比较直观的算法，从尾部向头部找到相应位置并插入数据，保证前面数据都是有序的。不断向后扫描未排序数据。

![插入排序](../images/200803/insertion.gif)

代码实现：

```javascript
function insertionSort(arr) {
  let preIndex, current;
  for(let i = 1; i < arr.length; i++) {
    preIndex = i - 1;
    current = arr[i];
    while(preIndex >= 0; && arr[preIndex] > current) {
      arr[preIndex+1] = arr[preIndex];
      preIndex--;
    }
    arr[preIndex] = current;
  }
  return arr;
}
```

## 4、希尔排序

希尔排序是插入排序的一个改进版本，它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

- 选择一个增量序列 t1，t2，…，tk，其中 ti>tj，tk=1；
- 按增量序列个数 k，对序列进行 k 趟排序；
- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

![插入排序](../images/200803/shell.gif)

```javascript
function shellSort(arr) {
  let len = arr.length;
  let temp,
    gap = Math.floor(len / 2);
  while (gap > 0) {
    for (let i = gap; i < len; i++) {
      temp = arr[i];
      let preIndex = i - gap;
      while (preIndex >= 0 && arr[preIndex] > temp) {
        arr[preIndex + gap] = arr[preIndex];
        preIndex -= gap;
      }
      arr[preIndex + gap] = temp;
    }
    gap = Math.floor(gap / 2);
  }
  return arr;
}
```

## 5、归并排序

该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，将已有序的子序列合并，得到有序的序列。

- 把长度为 n 的输入序列分成两个长度为 n/2 的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

![归并排序](../images/200803/merge.gif)

```javascript
function mergeSort(arr) {
  let len = arr.length;
  if (len < 2) {
    return arr;
  }
  let middle = Math.floor(len / 2),
    left = arr.slice(0, middle),
    right = arr.slice(middle, len);
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  let result = [];
  while (left.length > 0 && right.length > 0) {
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  while (left.length) result.push(left.shift());
  while (right.length) result.push(right.shift());
  return result;
}
```

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间来换取时间。

## 6、快速排序

快排的主要思路是，通过一次排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

![快速排序](../images/200803/quick.gif)

```javascript
function quickSort(arr, left, right) {
  let len = arr.length,
    partitionIndex,
    left = typeof left != "number" ? 0 : left,
    right = typeof right != "number" ? len - 1 : right;

  if (left < right) {
    partitionIndex = partition(arr, left, right);
    quickSort(arr, left, partitionIndex - 1);
    quickSort(arr, partitionIndex + 1, right);
  }
  return arr;
}

function partition(arr, left, right) {
  // 分区操作
  let pivot = left, // 设定基准值（pivot）
    index = pivot + 1;
  for (let i = index; i <= right; i++) {
    if (arr[i] < arr[pivot]) {
      swap(arr, i, index);
      index++;
    }
  }
  swap(arr, pivot, index - 1);
  return index - 1;
}

function swap(arr, i, j) {
  let temp = arr[i];
  arr[i] = arr[j];
  arr[j] = temp;
}
```

阮大大简易版

```javascript
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  let pivotIndex = Math.floor(arr.length / 2);
  let pivot = arr.splice(pivotIndex, 1)[0];
  let left = [];
  let right = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

## 参考

- [_十大经典排序算法（动图演示）_ --一像素](https://www.cnblogs.com/onepixel/articles/7674659.html)
