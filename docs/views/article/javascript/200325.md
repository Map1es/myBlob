---
title: 浅谈作用域和闭包问题
date: 2020-03-25
categories:
  - 前端
tags:
  - JavaScript
---

## 一、前言

很多人面试都会被问到什么是闭包，这个问题我也反反复复看过很多次，下面我就来总结一下我自己的见解，也方便自己复习。

## 二、不得不说的作用域

::: tip
个人认为，闭包就是对某个函数传到该词法作用域以外的地方调用（简略的说，可能有错，请各位斧正）。所以应该解释一下作用域是什么
:::

作用域主要有两种工作模型，第一种就是大多数编程语言所采用的词法作用域，另一种叫做动态作用域（有兴趣的同学可以去搜一下）。JavaScript 当然所采用的是词法作用域（以下都统称作用域）。

编译器在开始工作时，第一个阶段叫做词法化，就是将代码中的字符进行检查，如果时有状态的解析过程，还会赋予单词语义。（这也是叫词法作用域的原因）总的来说，词法作用域是由你写代码时将变量和块作用域写在哪里来决定的。例：

```javascript
// A
function foo(a) {
  // B
  var b = a * 2;

  function bar(c) {
    // C
    console.log(a, b, c);
  }

  bar(b * 3);
}

foo(2); // 2, 4, 12
```

以上就包括了 3 个作用域

- A 为最外层，包含整个全局作用域，其中只有标识符 `foo`
- B 为函数 `foo` 所创建的作用域，其中包含 `a, b, bar` 三个标识符
- C 为 `bar` 所创建的作用域， 其中只有 `c` 标识符

每一个函数都会创建一个新的作用域，它是逐级包含的，外层作用域的变量，在里层也可以调用。但是在外层调用不了里层的变量和函数，比如在 A 作用域就调用不了`bar`函数。

当然除了函数作用域，还有一种叫做块作用域，很多刚开始接触 js 的人认为只要有`{}`包裹的代码就是块作用域（。。。先接触 C 的菜鸡本人开始也是这样认为的），但实际上形成块作用域需要一下三种方法

- `with`
- `try/catch`
- `let`

`with`现在一般很少人用，我这就不细讲，有兴趣可以自己搜一下；`try/catch` 只要接触过编程的人一般都知道，在`catch`分句回创建一个块作用域，传入的异常参数只在`catch`中有效；`let` 本人认为这个关键字改变了在 ES5 之前变量莫名其妙被覆盖的状况，其实也解决了闭包难理解的问题。

`let` 可以将变量绑定到任意作用域中，使用`let`定义变量，就可以认为在`{}`中都是一个块作用域。

```javascript
let a = 2;
if (a) {
  var b = 2;
}
console.log(b); // 2

if (a) {
  let b = 2;
}
console.log(b);
// 报错，b不存在
```

第二个例子报错就是因为，在`{}`中用`let`声明的变量`b`形成了个块作用域，外部调用不了它

## 三、闭包的基础概念

:::tip
在对作用域有一定理解之后，我们就可以对闭包进行学习了。在初学 JavaScript 的时候，每个人都谈虎色变，因为它太难理解了，但是好像又不得不掌握它，当别人问起时也说不清道不明。但实际上，闭包并不是一个特别的东西，我们可能在不知情的时候已经使用了闭包，只是我们并不理解这是闭包。以下观点都是我参照各个大佬的文章和书籍进行理解总结的，如果有错欢迎指正。
:::

当然，我们先看看闭包的定义是什么：

> **当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。**

举个书里的例子：

```javascript
function foo() {
  var a = 2;
  function bar() {
    console.log(a); // 2
  }
  bar();
}
foo();
```

`bar`函数在全局作用域执行，但是却能调用`foo`函数作用域中的变量`a`，记住并访问了它原本所在的作用域。这里就可以说`bar`具有一个包含`foo`作用域的闭包。

可能这个例子不够清晰，我们换个写法:

```javascript
function foo() {
  var a = 2;
  function bar() {
    console.log(a); // 2
  }
  return bar;
}
var baz = foo();
baz();
```

我们直接把`bar`函数传出来赋予变量`baz`，这时我们可以确定，`bar`的作用域已经变成全局作用域，而它仍然可以调用`foo`中的变量`a`。

可能我这里解释的还不够清楚，大家也不了解闭包有什么特殊作用。这里又和 js 垃圾回收机制有点关系（具体可以去翻翻红宝书或者百度一下）。

我们先看下这段代码的执行过程：

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 `foo` 函数，创建 `foo` 函数执行上下文，`foo` 执行上下文被压入执行上下文栈
4. `foo` 执行上下文初始化，创建变量对象、作用域链、this 等
5. `foo` 函数执行完毕，`foo` 执行上下文从执行上下文栈中弹出
6. 执行 `bar` 函数，创建 `bar` 函数执行上下文，`bar` 执行上下文被压入执行上下文栈
7. `bar` 执行上下文初始化，创建变量对象、作用域链、this 等
8. `bar` 函数执行完毕，`bar` 函数上下文从执行上下文栈中弹出

了解这个执行过程后，我们可以发现，`foo`函数在执行过后直接就被 js 的垃圾回收机制销毁了，但是后面我们执行`bar`的时候却还能拿到里面的变量`a`。这是为什么呢，这就是因为闭包的力量，闭包可以阻止内部作用域被回收，因为`bar()`声明的位置，它拥有了包含`foo()`内部作用域的闭包，这个内部作用域会让`bar`在任何时间进行引用。

以上就是我对闭包的理解和解释。思路和文笔不好，如果还没看懂的话建议去看一下`《你不知道的JavaScript 上卷》` 我觉得里面写的很清晰

## 结语

这是本人对知识点总结的第二篇文章，如果有哪里写的不好，请多加指正。

最后，我们来个面试必考题测试一下

```javascript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

这里的运行结果可能大家都知道了，会输出5个6。至于原因又涉及到了eventLoop，就等下篇文章解析。也是为了让自己有动力写下去。。

## 参考

- 《你不知道的JavaScript 上卷》
- [*JavaScript深入之闭包* --冴羽](https://github.com/mqyqingfeng/Blog/issues/9)
