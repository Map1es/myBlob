---
title: JavaScript数据类型
date: 2019-11-23
categories:
  - 前端
tags:
  - JavaScript
---

## 一、简介

```JavaScript``` 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型一共有七种。

- ```Number```：数值类型，包括整数和小数
- ```String```：字符串类型
- ```Boolean```：布尔类型，包括 true 和 false
- ```undefined```：表示未定义或者不存在
- ```null```：表示空值
- ```Object```：对象类型，各种值的集合
- ```Symbol```：表示唯一值（ES6 新增）

通常它们被分为**基本类型**和**引用类型**，基本类型包括```数值```、```字符串```、```布尔值```、```Symbol```，引用类型只有 ```对象```（包括了普通的对象、数组、函数等），而 ```undefined``` 和 ```null``` 属于特殊值。

## 二、基本类型和引用类型区别

:::tip
重点是两者如何存在于内存中
:::

### 2.1 认识栈内存与堆内存

在 JavaScript 中，每一个变量都需要一个内存空间来存储。
内存空间又分为两种：**栈内存**与**堆内存**

栈内存：

- 存储的值大小固定
- 可以直接操作其保存变量，运行效率高
- 由系统自动分配存储空间

基本类型的值被直接存储在栈中，变量定义时就为其分配好内存空间

由于栈中的内存大小是固定的，所以在给变量重新赋值时，其实是开辟了一个新的内存空间，再将此变量指向新的内存空间

```javascript
let a = 1
let b = "test1"
```

| 变量名 |   值    |
| :----: | :-----: |
|   a    |    1    |
|   b    | "test1" |

```javascript
b = "test2";
```

| 变量名 |   值    |
| :----: | :-----: |
|   a    |    1    |
|        | "test1" |
|   b    | "test2" |

堆内存：

- 存储的值大小不定，可以动态调整
- 无法直接操作其内部存储，使用引用地址读取，运行效率低
- 通过代码进行分配空间

引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。

![堆内存](../../images/191123.png )

### 2.2 变量赋值的区别

基本类型在赋值时，会创建一块新的空间存储该值，虽然二者值相同，但是二者所在的内存空间不同，所以对他们进行操作时互不影响

引用类型再赋值时，只是将栈中的存储地址赋予新的变量，所以二者指向的是同一个内存空间，操作时会相互影响

### 2.3 比较

因为两个变量在比较时，是用栈中存储的值进行比较，基本类型在比较时，只要值相等，就会返回true，而然引用类型在栈中存储的是引用地址，所以就算两个对象中的键值对一样，它们也不一定相等

## 三、null与undefined存在的必要性

null

表示被赋值过的对象，刻意把一个对象赋值为 ```null``` ，故意表示其为空，不应有值。

所以对象的某个属性值为 ```null``` 是正常的，```null``` 转换为数值时值为 ```0```。

undefined

表示“缺少值”，即此处应有一个值，但还没有定义，如果一个对象的某个属性值为 ```undefined``` ，这是不正常的，如 ```obj.name=undefined```，我们不应该这样写，应该直接 ```delete obj.name```。

```undefined``` 转为数值时为 ```NaN``` (非数字值的特殊值)

### 2.1 编译型语言与解释型语言

想要了解为什么需要有undefined的存在，就要先了解编译型语言与解释型语言

- 编译型语言

（1）只须编译一次就可以把源代码编译成机器语言，后面的执行无须重新编译，直接使用之前的编译结果就可以；因此其执行的效率比较高；

（2）编译性语言代表：C、C++、Pascal/Object Pascal（Delphi）；

（3）程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些；

- 解释型语言

（1）源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行；

（2）程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；

（3）解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；

（4）运行效率一般相对比较低，依赖解释器，跨平台性好；

总的来说，```JavaScript``` 属于解释型语言，在书写代码时，变量是否存在要在代码编译后才能知道，所以有可能会发生使用了某个变量却没有定义的情况。

## 四、判断JavaScript数据类型的方式

### 4.1 typeof

```typeof``` 能准确判断一个变量是否为基础类型

```javascript
typeof 'ConardLi'  // string
typeof 123  // number
typeof true  // boolean
typeof Symbol()  // symbol
typeof undefined  // undefined
```

并且还能判断是否为函数

```javascript
typeof function() {}  // function
```

但是判断除了函数的其他引用类型时，只会返回Object

```javascript
typeof [] // object
typeof {} // object
typeof /^123/ // object
typeof null // object
```

### 4.2 instanceof

```instanceof``` 操作符可以帮助我们判断引用类型具体是什么类型的对象

```javascript
[] instanceof Array // true
new Date() instanceof Date // true
new RegExp() instanceof RegExp // true
```

该操作符是根据引用类型是否在该变量的**原型链**（具体请看原型与原型链相关）上进行判断，所以以下也是成立的：

```javascript
[] instanceof Object // true
```

### 4.3 toString

因为以上的两种方法都不能立即分辨出该变量的具体类型，所以我们可以用引用类型的拆箱操作进行准确判断变量类型

:::tip
每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中type是对象的类型。
:::

```javascript
function(a){
  return Object.prototype.toString.call(a).slice(8,-1)
}
```

| 调用 |   结果    |
| :----: | :-----: |
|   Object.prototype.toString.call(true)    |    [Object Boolean]    |
|   Object.prototype.toString.call(123)    |    [Object Number]    |
|   Object.prototype.toString.call('str')    |    [Object String]    |
|   Object.prototype.toString.call(null)    |    [Object Null]    |
|   Object.prototype.toString.call(Symbol())    |    [Object Symbol]    |
|   Object.prototype.toString.call({})    |    [Object Object]    |
|   Object.prototype.toString.call([])    |    [Object Array]    |
|   Object.prototype.toString.call(new RegExp())    |    [Object RegExp]    |
|   Object.prototype.toString.call(JSON)    |    [Object JSON]    |

## 参考

- [*你真的掌握变量和类型了吗* --ConardLilv](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)
- [*ES6入门* --阮一峰](http://es6.ruanyifeng.com/)
- 《JS高级程序设计》
