---
title: 面试要点总结
date: 2020-05-18
categories:
  - 前端
tags:
  - 面试
---

## `Javascript` 基础

### 基本数据类型有哪些

null、undefined、Number、String、Boolean、Object、Symbol(ES6 新增)

### var、let、const 的区别

- `var` 会发生变量提升现象，即变量声明语句可以放在变量使用后，`let` 和 `const` 不行

- `var` 可重复声明，后面声明的变量的值会覆盖之前声明的值，`let` 和 `const` 不行

- `let` 声明时会生成块级作用域，只有在该作用域内才能使用该变量

- `const` 声明的变量后不能改变它的值

### 什么是闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即函数是在当前词法作用域之外执行。一般是指，在函数执行完销毁后，外部还能读取到函数里面的变量。

作用：1、封装私有变量 2、让某些值始终保存在内存中

### new 的意义以及实现方法

任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象。

```javascript
function New(fn, ...arg) {
  // 用构造函数的原型创建一个空对象
  const object = Object.create(fn.prototype);
  // 执行构造函数，进行赋值等操作
  const ret = fn.apply(object, arg);
  // 如果构造函数有return操作则返回构造函数返回值，没有则返回对象
  return ret instanceof Object ? ret : object;
}
```

### call,apply,bind 的区别

1. call()

   第一个参数是目标对象，之后的多个参数是函数调用时所需的参数

2. apply()

   和 call 一样，但是之后的参数必须以数组的形式添加

3. bind()

   用于将函数体内的 this 绑定到某个对象，然后返回一个新函数

```javascript
// apply 只是参数不同
Function.prototype.myCall = function(thisArg, ...args) {
  if (typeof thisArg !== "function") {
    throw new TypeError("not function");
  }
  const fn = Symbol("fn");
  thisArg = thisArg || window;
  thisArg[fn] = this;
  let result = thisArg[fn](...args);
  delete thisArg[fn];
  return result;
};
```

```javascript
Function.prototype.myBind = function(thisArg, ...args) {
  if (typeof this !== "function") {
    throw TypeError("Bind must be called on a function");
  }
  let self = this;
  // new优先级
  let fbound = function() {
    self.apply(
      this instanceof self ? this : thisArg,
      args.concat(Array.prototype.slice.call(arguments))
    );
  };
  // 继承原型上的属性和方法
  fbound.prototype = Object.create(self.prototype);
  return fbound;
};
```

### 原型和原型链

每个函数都有一个`prototype`属性，它是指向函数原型的一个指针，而构造函数同样有自己的原型对象。通过构造函数生成的对象实例中，都有一个`__proto__`属性，它指向构造函数的原型对象。

原型链是指当对象属性或函数在被引用时，如果在当前对象没有找到该属性或函数，就会在当前对象的原型上寻找，如果还有没有，就会继续往上层的原型对象上找。

### 继承
