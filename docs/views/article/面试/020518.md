---
title: 题集
date: 2020-05-18
categories:
  - 前端
tags:
  - 面试
---

## html

### script 标签中 defer 和 async 的区别

- defer：浏览器指示脚本在文档被解析后执行，script 被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。

- async：同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致 async 属性下的脚本是乱序的，对于 script 有先后依赖关系的情况，并不适用。

### 前端的存储方式

- cookies： 在 HTML5 标准前本地储存的主要方式，优点是兼容性好，请求头自带 cookie 方便，缺点是大小只有 4k，自动请求头加入 cookie 浪费流量，每个 domain 限制 20 个 cookie，使用起来麻烦需要自行封装

- localStorage：HTML5 加入的以键值对(Key-Value)为标准的方式，优点是操作方便，永久性储存（除非手动删除），大小为 5M，兼容 IE8+

- sessionStorage：与 localStorage 基本类似，区别是 sessionStorage 当页面关闭后会被清理，而且与 cookie、localStorage 不同，他不能在所有同源窗口中共享，是会话级别的储存方式

- Web SQL：2010 年被 W3C 废弃的本地数据库数据存储方案，但是主流浏览器（火狐除外）都已经有了相关的实现，web sql 类似于 SQLite，是真正意义上的关系型数据库，用 sql 进行操作，当我们用 JavaScript 时要进行转换，较为繁琐。

- IndexedDB： 是被正式纳入 HTML5 标准的数据库储存方案，它是 NoSQL 数据库，用键值对进行储存，可以进行快速读取操作，非常适合 web 场景，同时用 JavaScript 进行操作会非常方便。

## CSS

### css 选择器优先级

CSS 选择器的优先级是：内联 > ID 选择器 > 类选择器 > 标签选择器

到具体的计算层面，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：

- A 的值等于 1 的前提是存在内联样式, 否则 A = 0;
- B 的值等于 ID 选择器 出现的次数;
- C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;
- D 的值等于 标签选择器 和 伪元素 出现的总次数 。

就比如下面的选择器，它不存在内联样式，所以 A=0,不存在 id 选择器 B=0,存在一个类选择器 C=1,存在三个标签选择器 D=3，那么最终计算结果为: {0, 0, 1 ,3}

```css
ul ol li .red {
  ...;
}
```

按照这个结算方式，下面的计算结果为: {0, 1, 0, 0}

```css
ul ol li .red {
  ...;
}
```

我们的比较优先级的方式是从 A 到 D 去比较值的大小，A、B、C、D 权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。

比如第二个例子的 B 与第一个例子的 B 相比，1>0,接下来就不需要比较了，第二个选择器的优先级更高。

### px em rem vw vh 等单位

- px：绝对单位，页面按精确像素展示。
- em：相对单位，基准点为父节点字体的大小，如果自身定义了 font-size 按自身来计算（浏览器默认字体是 16px），整个页面内 1em 不是一个固定的值。
- rem：相对单位，可理解为”root em”, 相对根节点 html 的字体大小来计算，CSS3 新加属性，chrome/firefox/IE9+支持
- vw：1vw 等于适口宽度的 1%；vh：1vh 等于适口高度的 1%；

## `Javascript` 基础

### 基本数据类型有哪些

null、undefined、Number、String、Boolean、Object、Symbol(ES6 新增)

### 类型判断方法

- typeof  
  只能判断基础类型，但不能判断对象和数组

### null 与 undefined 的区别是什么

- null  
  表示被赋值过的对象，刻意把一个对象赋值为 `null` ，故意表示其为空，不应有值。  
  所以对象的某个属性值为 `null` 是正常的，`null` 转换为数值时值为 `0`。

- undefined  
  表示“缺少值”，即此处应有一个值，但还没有定义，如果一个对象的某个属性值为 `undefined` ，这是不正常的，如 `obj.name=undefined`，我们不应该这样写，应该直接 `delete obj.name`。  
  `undefined` 转为数值时为 `NaN` (非数字值的特殊值)

### var、let、const 的区别

- `var` 会发生变量提升现象，即变量声明语句可以放在变量使用后，`let` 和 `const` 不行

- `var` 可重复声明，后面声明的变量的值会覆盖之前声明的值，`let` 和 `const` 不行

- `let` 声明时会生成块级作用域，只有在该作用域内才能使用该变量

- `const` 声明的变量后不能改变它的值

### 什么是闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即函数是在当前词法作用域之外执行。一般是指，在函数执行完销毁后，外部还能读取到函数里面的变量。

作用：1、封装私有变量 2、让某些值始终保存在内存中

### new 的意义以及实现方法

任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象。

```javascript
function New(fn, ...arg) {
  // 用构造函数的原型创建一个空对象
  const object = Object.create(fn.prototype);
  // 执行构造函数，进行赋值等操作
  const ret = fn.apply(object, arg);
  // 如果构造函数有return操作则返回构造函数返回值，没有则返回对象
  return ret instanceof Object ? ret : object;
}
```

### this 是什么

this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用  
判断绑定方法

1. 由 new 调用？绑定到新创建的对象。
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。

### call,apply,bind 的区别

1. call()

   第一个参数是目标对象，之后的多个参数是函数调用时所需的参数

2. apply()

   和 call 一样，但是之后的参数必须以数组的形式添加

3. bind()

   用于将函数体内的 this 绑定到某个对象，然后返回一个新函数

```javascript
// apply 只是参数不同
Function.prototype.myCall = function(thisArg, ...args) {
  if (typeof thisArg !== "function") {
    throw new TypeError("not function");
  }
  const fn = Symbol("fn");
  thisArg = thisArg || window;
  thisArg[fn] = this;
  let result = thisArg[fn](...args);
  delete thisArg[fn];
  return result;
};
```

```javascript
Function.prototype.myBind = function(thisArg, ...args) {
  if (typeof this !== "function") {
    throw TypeError("Bind must be called on a function");
  }
  let self = this;
  // new优先级
  let fbound = function() {
    self.apply(
      this instanceof self ? this : thisArg,
      args.concat(Array.prototype.slice.call(arguments))
    );
  };
  // 继承原型上的属性和方法
  fbound.prototype = Object.create(self.prototype);
  return fbound;
};
```

### 原型和原型链

每个函数都有一个`prototype`属性，它是指向函数原型的一个指针，而构造函数同样有自己的原型对象。通过构造函数生成的对象实例中，都有一个`__proto__`属性，它指向构造函数的原型对象。

原型链是指当对象属性或函数在被引用时，如果在当前对象没有找到该属性或函数，就会在当前对象的原型上寻找，如果还有没有，就会继续往上层的原型对象上找。

### 继承

### ES6 模块与 CommonJS 模块区别

- `CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。
- `CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。

### promise

promise 是一种为了解决回调地狱的异步解决方案。它有两个特点：

1. 对象的状态不收外界影响，只有异步操作的结果可以决定当前是哪种状态，其他任何操作都不能改变这个状态；
2. 状态改变后就不会再变化了，它只有两种可能：pending 变为 fulfilled 和 pending 变为 rejected。

### async/await

async 函数，就是 Generator 函数的语法糖，它建立在 Promises 上，并且与所有现有的基于 Promise 的 API 兼容。

- `Async`—声明一个异步函数(async function someName(){...})

1. 自动将常规函数转换成 Promise，返回值也是一个 Promise 对象
2. 只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数
3. 异步函数内部可以使用 await

- `Await`—暂停异步的功能执行(var result = await someAsyncCall())

1. 放置在 Promise 调用之前，await 强制其他代码等待，直到 Promise 完成并返回结果
2. 只能与 Promise 一起使用，不适用与回调
3. 只能在 async 函数内部使用

## Vue

### 什么是MVVM

mvvm model是模型，表示数据模型的意思，例如数据库查出的数据；view是视图，就是渲染出来的页面；viewModel是将视图和模型绑定的一种关系，视图完全由模型返回的数据驱动，例如在vue中就利用es5的 Object.defineProperty的getter/setter方法，进行双向绑定。

### vue 生命周期

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

| 生命周期      | 描述                                                                   |
| :------------ | :--------------------------------------------------------------------- |
| beforeCreate  | 组件实例被创建之初，组件的属性生效之前                                 |
| created       | 组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，\$el 还不可用 |
| beforeMount   | 在挂载开始之前被调用：相关的 render 函数首次被调用                     |
| mounted       | el 被新创建的 vm.\$el 替换，并挂载到实例上去之后调用该钩子             |
| beforeUpdate  | 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前                        |
| update        | 组件数据更新之后                                                       |
| activited     | keep-alive 专属，组件被激活时调用                                      |
| deadctivated  | keep-alive 专属，组件被销毁时调用                                      |
| beforeDestory | 组件销毁前调用                                                         |
| destoryed     | 组件销毁后调用                                                         |

### 组件通信方式

Vue 组件通信的方法如下:

- props/$emit+v-on: 通过props将数据自上而下传递，而通过$emit 和 v-on 来向上传递信息。（常用）
- EventBus: 通过 EventBus 进行信息的发布与订阅 （全局创建一个 vue 实例来当缓存仓库，容易混淆，不建议使用）
- vuex: 是全局数据管理库，可以通过 vuex 管理全局的数据流（项目较大时需要）
- $attrs/$listeners: Vue2.4 中加入的$attrs/$listeners 可以进行跨级的组件通信 (包含了父作用域中不作为 prop 被识别 (且获取) 的 属性/方法 绑定)
- provide/inject：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效，这成为了跨组件通信的基础

### computed 和 watch 的区别

- computed

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算
2. 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化
3. computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值
4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed
5. 如果 computed 属性属性值是函数，那么默认会走 get 方法；函数的返回值就是属性的属性值；在 computed 中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法。

- watch

1. 不支持缓存，数据变，直接会触发相应的操作；
2. watch 支持异步；
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4. 当一个属性发生变化时，需要执行对应的操作；一对多；
5. 监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据，当数据变化时，触发其他操作，函数有两个参数：  
   immediate：组件加载立即触发回调函数执行;  
   deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep 无法监听到数组的变动和对象的新增，参考 vue 数组变异,只有以响应式的方式触发才会被监听到。
