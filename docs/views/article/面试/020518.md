---
title: 题集
date: 2020-05-18
categories:
  - 前端
tags:
  - 面试
---
## html

### script标签中defer和async的区别

- defer：浏览器指示脚本在文档被解析后执行，script被异步加载后并不会立刻执行，而是等待文档被解析完毕后执行。

- async：同样是异步加载脚本，区别是脚本加载完毕后立即执行，这导致async属性下的脚本是乱序的，对于script有先后依赖关系的情况，并不适用。

### 前端的存储方式

- cookies： 在HTML5标准前本地储存的主要方式，优点是兼容性好，请求头自带cookie方便，缺点是大小只有4k，自动请求头加入cookie浪费流量，每个domain限制20个cookie，使用起来麻烦需要自行封装

- localStorage：HTML5加入的以键值对(Key-Value)为标准的方式，优点是操作方便，永久性储存（除非手动删除），大小为5M，兼容IE8+

- sessionStorage：与localStorage基本类似，区别是sessionStorage当页面关闭后会被清理，而且与cookie、localStorage不同，他不能在所有同源窗口中共享，是会话级别的储存方式

- Web SQL：2010年被W3C废弃的本地数据库数据存储方案，但是主流浏览器（火狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，用sql进行操作，当我们用JavaScript时要进行转换，较为繁琐。

- IndexedDB： 是被正式纳入HTML5标准的数据库储存方案，它是NoSQL数据库，用键值对进行储存，可以进行快速读取操作，非常适合web场景，同时用JavaScript进行操作会非常方便。

## CSS

### css选择器优先级

CSS选择器的优先级是：内联 > ID选择器 > 类选择器 > 标签选择器

到具体的计算层面，优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：

- A 的值等于 1 的前提是存在内联样式, 否则 A = 0;
- B 的值等于 ID选择器 出现的次数;
- C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;
- D 的值等于 标签选择器 和 伪元素 出现的总次数 。

就比如下面的选择器，它不存在内联样式，所以A=0,不存在id选择器B=0,存在一个类选择器C=1,存在三个标签选择器D=3，那么最终计算结果为: {0, 0, 1 ,3}

```css
ul ol li .red {
    ...
}
```

按照这个结算方式，下面的计算结果为: {0, 1, 0, 0}

```css
ul ol li .red {
    ...
}
```

我们的比较优先级的方式是从A到D去比较值的大小，A、B、C、D权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。

比如第二个例子的B与第一个例子的B相比，1>0,接下来就不需要比较了，第二个选择器的优先级更高。

### px em rem vw vh等单位

- px：绝对单位，页面按精确像素展示。
- em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。
- rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持
- vw：1vw等于适口宽度的1%；vh：1vh等于适口高度的1%；

## `Javascript` 基础

### 基本数据类型有哪些

null、undefined、Number、String、Boolean、Object、Symbol(ES6 新增)

### 类型判断方法

- typeof  
  只能判断基础类型，但不能判断对象和数组

### null 与 undefined 的区别是什么

- null  
  表示被赋值过的对象，刻意把一个对象赋值为 `null` ，故意表示其为空，不应有值。  
  所以对象的某个属性值为 `null` 是正常的，`null` 转换为数值时值为 `0`。

- undefined  
  表示“缺少值”，即此处应有一个值，但还没有定义，如果一个对象的某个属性值为 `undefined` ，这是不正常的，如 `obj.name=undefined`，我们不应该这样写，应该直接 `delete obj.name`。  
  `undefined` 转为数值时为 `NaN` (非数字值的特殊值)

### var、let、const 的区别

- `var` 会发生变量提升现象，即变量声明语句可以放在变量使用后，`let` 和 `const` 不行

- `var` 可重复声明，后面声明的变量的值会覆盖之前声明的值，`let` 和 `const` 不行

- `let` 声明时会生成块级作用域，只有在该作用域内才能使用该变量

- `const` 声明的变量后不能改变它的值

### 什么是闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即函数是在当前词法作用域之外执行。一般是指，在函数执行完销毁后，外部还能读取到函数里面的变量。

作用：1、封装私有变量 2、让某些值始终保存在内存中

### new 的意义以及实现方法

任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象。

```javascript
function New(fn, ...arg) {
  // 用构造函数的原型创建一个空对象
  const object = Object.create(fn.prototype);
  // 执行构造函数，进行赋值等操作
  const ret = fn.apply(object, arg);
  // 如果构造函数有return操作则返回构造函数返回值，没有则返回对象
  return ret instanceof Object ? ret : object;
}
```

### this是什么

this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用  
判断绑定方法  

1. 由 new 调用？绑定到新创建的对象。
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。

### call,apply,bind 的区别

1. call()

   第一个参数是目标对象，之后的多个参数是函数调用时所需的参数

2. apply()

   和 call 一样，但是之后的参数必须以数组的形式添加

3. bind()

   用于将函数体内的 this 绑定到某个对象，然后返回一个新函数

```javascript
// apply 只是参数不同
Function.prototype.myCall = function(thisArg, ...args) {
  if (typeof thisArg !== "function") {
    throw new TypeError("not function");
  }
  const fn = Symbol("fn");
  thisArg = thisArg || window;
  thisArg[fn] = this;
  let result = thisArg[fn](...args);
  delete thisArg[fn];
  return result;
};
```

```javascript
Function.prototype.myBind = function(thisArg, ...args) {
  if (typeof this !== "function") {
    throw TypeError("Bind must be called on a function");
  }
  let self = this;
  // new优先级
  let fbound = function() {
    self.apply(
      this instanceof self ? this : thisArg,
      args.concat(Array.prototype.slice.call(arguments))
    );
  };
  // 继承原型上的属性和方法
  fbound.prototype = Object.create(self.prototype);
  return fbound;
};
```

### 原型和原型链

每个函数都有一个`prototype`属性，它是指向函数原型的一个指针，而构造函数同样有自己的原型对象。通过构造函数生成的对象实例中，都有一个`__proto__`属性，它指向构造函数的原型对象。

原型链是指当对象属性或函数在被引用时，如果在当前对象没有找到该属性或函数，就会在当前对象的原型上寻找，如果还有没有，就会继续往上层的原型对象上找。

### 继承

### ES6 模块与 CommonJS 模块区别

- `CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。
- `CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。

## async/await

async 函数，就是 Generator 函数的语法糖，它建立在 Promises 上，并且与所有现有的基于 Promise 的 API 兼容。

- `Async`—声明一个异步函数(async function someName(){...})

1. 自动将常规函数转换成 Promise，返回值也是一个 Promise 对象
2. 只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数
3. 异步函数内部可以使用 await

- `Await`—暂停异步的功能执行(var result = await someAsyncCall()😉

1. 放置在 Promise 调用之前，await 强制其他代码等待，直到 Promise 完成并返回结果
2. 只能与 Promise 一起使用，不适用与回调
3. 只能在 async 函数内部使用
